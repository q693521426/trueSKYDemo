//  Copyright (c) 2015 Simul Software Ltd. All rights reserved.
#include "shader_platform.sl"
#include "../SL/common.sl"
#include "../SL/render_states.sl"
#include "../SL/depth.sl"
#include "../SL/hdr_constants.sl"
#include "../SL/colour_packing.sl"
#include "../SL/simul_inscatter_fns.sl"
#include "../SL/composite.sl"
#include "../SL/composite_msaa.sl"
#include "../SL/debug_constants.sl"
#include "../SL/noise.sl"

uniform Texture2D imageTexture;
uniform TEXTURE2DMS_FLOAT4 imageTextureMS;
uniform TextureCubeArray imageCubeArray;
uniform TextureCube nearFarTexture;
uniform TextureCube lightpassTexture;
uniform Texture2D depthTexture					SIMUL_TEXTURE_REGISTER(1);
uniform TEXTURE2DMS_FLOAT4 depthTextureMS		SIMUL_TEXTURE_REGISTER(1);
uniform TEXTURE2D_UINT glowTexture;

uniform Texture2D inscatterTexture;				// Far, or default inscatter
uniform Texture2D loss2dTexture;
uniform Texture3D inscatterVolumeTexture;
uniform Texture3D godraysVolumeTexture;

struct CompositeShaderInput
{
    vec4 hPosition			:SV_POSITION;
    vec2 texCoords			:TEXCOORD0;
    vec2 lowResTexCoords	:TEXCOORD1;
	vec4 clip_pos			:TEXCOORD2;
	vec2 depth_texc			:TEXCOORD3;
};

vec4 texture_resolve(TEXTURE2DMS_FLOAT4 textureMS,vec2 texCoords)
{
	uint2 dims;
	uint numberOfSamples;
	GET_DIMENSIONS_MSAA(textureMS,dims.x,dims.y,numberOfSamples);
	int2 pos=int2(vec2(dims)*texCoords);
	vec4 d=vec4(0,0,0,0);
	for(uint k=0;k<numberOfSamples;k++)
	{
		d+=TEXTURE_LOAD_MSAA(textureMS,pos,k);
	}
	d/=float(numberOfSamples);
	return d;
}

shader CompositeShaderInput VS_Composite(idOnly IN)
{
	CompositeShaderInput OUT;
	vec2 poss[4]=
	{
		{ 1.0,-1.0},
		{ 1.0, 1.0},
		{-1.0,-1.0},
		{-1.0, 1.0},
	};
	vec2 pos		=poss[IN.vertex_id];
	OUT.hPosition	=vec4(pos,0.0,1.0);
	OUT.hPosition.z	=0.0; 
	OUT.texCoords	=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));

	OUT.lowResTexCoords	=OUT.texCoords.xy;
	OUT.clip_pos		=vec4(-1.0,1.0,1.0,1.0);
	OUT.clip_pos.x		+=2.0*OUT.texCoords.x;
	OUT.clip_pos.y		-=2.0*OUT.texCoords.y;
	OUT.depth_texc		=viewportCoordToTexRegionCoord(OUT.texCoords.xy, viewportToTexRegionScaleBias);
    return OUT;
}

shader vec4 ShowDepthPS_ReverseDepth(posTexVertexOutput IN) : SV_Target
{
	vec4 depth = depthTexture.Sample(clampSamplerState,IN.texCoords);
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=true;
	float dist = 10.0*depthToFadeDistance(depth.x, 2.0*(IN.texCoords - 0.5), depthInterpretationStruct, tanHalfFov);
	vec4 u = vec4(1, dist, dist, 1.0);
	return u;
}

shader vec4 ShowDepthPS_ForwardDepth(posTexVertexOutput IN) : SV_Target
{
	vec4 depth		=texture_clamp(depthTexture,IN.texCoords);
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=false;
	float dist		=10.0*depthToFadeDistance(depth.x,2.0*(IN.texCoords-0.5),depthInterpretationStruct,tanHalfFov);
    vec4 u=vec4(1,dist,dist,1.0);
	return u;
}

/*
 The Filmic tone mapper is from: http://filmicgames.com/Downloads/GDC_2010/Uncharted2-Hdr-Lighting.pptx
These numbers DO NOT have the pow(x,1/2.2) baked in
*/
vec3 FilmicTone(vec3 x)
{
	float A				=0.22;	//Shoulder Strength
	float B				=0.30;	//Linear Strength
	float C				=0.10;	//Linear Angle
	float D				=0.20;	//Toe Strength
	float E				=0.01;	//Toe Numerator
	float F				=0.30;	//Toe Denominator
	//Note: E/F = Toe Angle
	float LinearWhite	=1.2;	//Linear White Point Value
	vec3 Fx				= ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F)) - E/F;
	float Fw				= ((LinearWhite*(A*LinearWhite+C*B)+D*E)/(LinearWhite*(A*LinearWhite+B)+D*F)) - E/F;
	vec3 c				= Fx/Fw;
	return c;
}

shader vec4 GlowExposureGammaPS(posTexVertexOutput IN) : SV_Target
{
	vec4 c		=texture_nearest_lod(imageTexture,IN.texCoords,0);
	vec4 glow	=texture_int(glowTexture,IN.texCoords);
	c.rgb		+=glow.rgb;
	c.rgb		*=exposure;
	c.rgb		=pow(c.rgb,vec3(gamma,gamma,gamma));
    vec4 u=vec4(c.rgb,1.0);
	return u;
}

shader vec4 GlowExposureGammaPS_MSAA(posTexVertexOutput IN) : SV_Target
{
	vec4 c=texture_resolve(imageTextureMS,IN.texCoords);
	vec4 glow=texture_int(glowTexture,IN.texCoords);
	c.rgb+=glow.rgb;
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
    vec4 u=vec4(c.rgb,1.0);
	return u;
}

shader vec4 PS_InfraRed(posTexVertexOutput IN) : SV_Target
{
	vec4 c					=texture_clamp(imageTexture,IN.texCoords);
    c.rgb					*=infraredIntegrationFactors.xyz;
    float final_radiance	=c.x+c.y+c.z;
	c=vec4(final_radiance,final_radiance,final_radiance,c.a);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
    vec4 u=vec4(c.rgb,1.0);
	return u;
}

shader vec4 PS_InfraRed_MSAA(posTexVertexOutput IN) : SV_Target
{
	vec4 c=texture_resolve(imageTextureMS,IN.texCoords);
    c.rgb					*=infraredIntegrationFactors.xyz;
    float final_radiance	=c.x+c.y+c.z;
	c=vec4(final_radiance,final_radiance,final_radiance,c.a);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
    vec4 u=vec4(c.rgb,1.0);
	return u;
}

shader posTexVertexOutput Debug2DVS(idOnly id)
{
    return VS_ScreenQuad(id,rect);
}

shader vec4 TexturedPS(posTexVertexOutput IN) : SV_Target
{
	vec4 res=vec4(0,1,0,1);
	return res;
}

shader vec4 PS_ShowCompressed(posTexVertexOutput IN) : SV_Target
{
	vec4 glow		=texture_int(glowTexture,IN.texCoords);
    vec4 u=vec4(glow.rgb,1.0);
	return u;
}

shader vec4 PS_ShowScatteringVolume(posTexVertexOutput IN) : SV_Target
{
	vec3 texc	=vec3(IN.texCoords,1.0);
	texc.y		*=2.0;
	if(texc.y<1.0)
	{
		texc.z=floor(8.0f*IN.texCoords.x)/8.0f;
	}
	else
	{
		texc.y-=1.0;
	}
	texc.x+=0.5;
	vec4 sc	=texture_3d_wwc_lod(inscatterVolumeTexture,texc,0);
  
    vec4 u	=vec4(sc.rgb,1.0);
	return u;
}

shader vec4 PS_ShowVolume(posTexVertexOutput IN) : SV_Target
{
	float z			=floor(8.0f*IN.texCoords.x)/8.0f;
	if(IN.texCoords.y<.5)
		z			=.5;
	vec4 colour		=texture_3d_nearest_lod(inscatterVolumeTexture,vec3(IN.texCoords,z),0);
	//colour.r = colour.a;
	return colour;
}

shader vec4 ExposureGammaPS(posTexVertexOutput IN) : SV_Target
{
	vec4 c	=imageTexture.Sample(samplerStateNearest,IN.texCoords);
	c.rgb	*=exposure;
	c.rgb	=pow(c.rgb,vec3(gamma,gamma,gamma));
    vec4 u	=vec4(c.rgb,1.0);
	return u;
}

shader vec4 ExposureGammaPS_MSAA(posTexVertexOutput IN) : SV_Target
{
	vec4 c=texture_resolve(imageTextureMS,IN.texCoords);
	c.rgb*=exposure;
	c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
    vec4 u=vec4(c.rgb,1.0);
	return u;
}


void UpdateNearestSample(	inout float MinDist,
							inout vec2 NearestUV,
							float Z,
							vec2 UV,
							float ZFull
							)
{
	float Dist = abs(Z - ZFull);
	if (Dist < MinDist)
	{
		MinDist = Dist;
		NearestUV = UV;
	}
}

bool IsSampleNearer(inout float MinDist,float Z,float ZFull)
{
	float Dist = abs(Z - ZFull);
	return (Dist < MinDist);
}


shader vec4 DirectPS(posTexVertexOutput IN) : SV_Target
{
	vec4 result	=texture_clamp(imageTexture,IN.texCoords.xy);
	vec4 insc	=texture_clamp(inscatterTexture,IN.texCoords);
	result		+=insc*result.a;
	result.rgb	=exposure*pow(result.rgb,vec3(gamma,gamma,gamma));
    return result;
}


TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN,bool process_depth,bool reverseDepth,bool doLightpass,bool doGodrays,bool doNear)
{
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;

	float depth						=depthTexture.SampleLevel(samplerStateNearestClamp,IN.depth_texc,0).x;
	float dist						=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
	TwoColourCompositeOutput result	=CompositeAtmospherics(IN.clip_pos
															,imageCubeArray
															,nearFarTexture
															,lightpassTexture
															,loss2dTexture
															,dist
															,invViewProj
															,viewPos
															,inscatterVolumeTexture
															,godraysVolumeTexture
															,maxFadeDistanceKm
															,nearDist
															,doLightpass
															,doGodrays
															,process_depth
															,doNear);
	//result.add.rgb	=pow(result.add.rgb,vec3(gamma,gamma,gamma));
	//result.add.rgb	*=exposure;
	return result;
}

TwoColourCompositeOutput PS_CompositeAtmospherics_Cubemap(CompositeShaderInput IN,bool reverseDepth)
{
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth=reverseDepth;
	vec3 view	=normalize(mul(invViewProj, IN.clip_pos).xyz);
	float sine	=view.z;
	// TODO: Custom planet radius here
	float R		=6378.0;
	float r		=R+max(1.0,viewPos.z/1000.0);
	// instead of a depth texture, we use an equation for dist based on our altitude.
	float dist	=1.0;
	float m		=R*R+r*r*(sine*sine-1.0);
	dist		=step(0.0,m)*(-r*sine-sqrt(max(0.0,m)))/maxFadeDistanceKm;
	if(dist<=0)
		dist=1.0;
	TwoColourCompositeOutput result	=	CompositeAtmospherics(IN.clip_pos
															,imageCubeArray
															,nearFarTexture
															,lightpassTexture
															,loss2dTexture
															,dist
															,invViewProj
															,viewPos
															,inscatterVolumeTexture
															,godraysVolumeTexture
															,maxFadeDistanceKm
															,nearDist
															,false,false,false,false);
	result.add.rgb	=pow(result.add.rgb,vec3(gamma,gamma,gamma));
	result.add.rgb	*=exposure;
	return result;
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,false,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,false,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,false,false,false);
}


shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_Lightpass(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,true,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_Lightpass(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,true,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_Lightpass(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,true,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,false,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,false,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,false,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_Lightpass_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,true,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_Lightpass_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,true,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_Lightpass_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,true,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,false,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,false,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,false,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_Lightpass_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,true,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_Lightpass_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,true,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_Lightpass_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,true,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,false,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,false,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,false,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ReverseDepth_Lightpass_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,true,true,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_ForwardDepth_Lightpass_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,true,false,true,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_NoDepth_Lightpass_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics(IN,false,true,true,true,true);
}




TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA(CompositeShaderInput IN,bool process_depth,bool reverseDepth,bool doLightpass,bool doGodrays,bool doNear)
{
	DepthInterpretationStruct depthInterpretationStruct;
	depthInterpretationStruct.depthToLinFadeDistParams	=depthToLinFadeDistParams;
	depthInterpretationStruct.reverseDepth				=reverseDepth;
	TwoColourCompositeOutput result						=CompositeAtmospherics_MSAA(IN.clip_pos
																					,IN.depth_texc
																					,imageCubeArray
																					,nearFarTexture
																					,lightpassTexture
																					,loss2dTexture
																					,depthTextureMS
																					,numSamples
																					,int2(fullResDims)
																					,invViewProj
																					,viewPos
																					,viewportToTexRegionScaleBias
																					,depthInterpretationStruct
																					,inscatterVolumeTexture
																					,godraysVolumeTexture
																					,nearDist
																					,doLightpass
																					,doGodrays
																					,process_depth
																					,doNear);
	result.add.rgb	=pow(result.add.rgb,vec3(gamma,gamma,gamma));
	result.add.rgb	*=exposure;
	return result;
}


shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,false,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,false,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,false,false,false);
}


shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,true,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,true,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,true,false,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,false,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,false,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,false,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,true,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,true,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass_Godrays(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,true,true,false);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,false,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,false,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,false,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,true,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,true,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,true,false,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,false,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,false,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,false,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,true,true,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,true,false,true,true,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass_Godrays_NearInterp(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_MSAA(IN,false,true,true,true,true);
}



shader vec4 PS_CubemapToScreenspace(posTexVertexOutput IN): SV_Target
{
	vec4 clip_pos		=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x			+=2.0*IN.texCoords.x;
	clip_pos.y			-=2.0*IN.texCoords.y;
	vec3 view			=mul(invViewProj,clip_pos).xyz;
	vec4 res			=texture_cube_lod(nearFarTexture,view,0);
	return res;
}


shader vec4 PS_CubemapToScreenspaceVisibility(posTexVertexOutput IN): SV_Target
{
	vec4 clip_pos		=vec4(-1.0,1.0,1.0,1.0);
	clip_pos.x			+=2.0*IN.texCoords.x;
	clip_pos.y			-=2.0*IN.texCoords.y;
	vec3 view			=mul(invViewProj,clip_pos).xyz;
	vec4 nearfar		=texture_cube_lod(nearFarTexture,view,0);
	vec4 img			=texture_cube_lod(imageCubeArray,vec4(view,0),0);
	vec4 result			=vec4(img.a,0,nearfar.zw);
	return result;
}
 
shader TwoColourCompositeOutput PS_CompositeAtmospherics_Cubemap_ReverseDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_Cubemap(IN,true);
}

shader TwoColourCompositeOutput PS_CompositeAtmospherics_Cubemap_ForwardDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_Cubemap(IN,false);
}
shader TwoColourCompositeOutput PS_CompositeAtmospherics_Cubemap_NoDepth(CompositeShaderInput IN) 
{
	return PS_CompositeAtmospherics_Cubemap(IN,true);
}
 
shader vec4 GlowPS(posTexVertexOutput IN) : SV_Target
{
    // original image has double the resolution, so we sample 2x2
    vec4 c=vec4(0,0,0,0);
	c+=texture_clamp(imageTexture,IN.texCoords+offset/2.0);
	c+=texture_clamp(imageTexture,IN.texCoords-offset/2.0);
	vec2 offset2=offset;
	offset2.x=offset.x*-1.0;
	c+=texture_clamp(imageTexture,IN.texCoords+offset2/2.0);
	c+=texture_clamp(imageTexture,IN.texCoords-offset2/2.0);
	c=c*exposure/4.0;
	c-=1.0*vec4(1.0,1.0,1.0,1.0);
	c=clamp(c,vec4(0.0,0.0,0.0,0.0),vec4(10.0,10.0,10.0,10.0));
    return c;
}

float safelog(float x)
{
	if(x<0.001)
		x=0.001;
	return log(x);
}

shader vec4 PS_Blur(posTexVertexOutput IN) : SV_Target
{
	float r1=rand(IN.texCoords.xy+vec2(11.19*randomSeed,2.3*randomSeed));
	float r2=rand(vec2(1.0,0.5)+13.09*IN.texCoords.xy-vec2(5.1*randomSeed,3.9*randomSeed));
	float rad		=sqrt(-2.0*safelog(r1));
	float angle		=2.0*pi*r2;
	vec2 sampleOffset=offset*rad*vec2(cos(angle),sin( angle ));
    vec4 c=texture_clamp_lod(imageTexture,IN.texCoords+sampleOffset,0);
    return vec4(c.rgb,alpha);
}

VertexShader mainvs_4_0=CompileShader(vs_4_0,VS_SimpleFullscreen());
VertexShader mainvs_5_0=CompileShader(vs_5_0,VS_SimpleFullscreen());
VertexShader compositevs_5_0=CompileShader(vs_5_0,VS_Composite());

technique exposure_gamma
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,ExposureGammaPS()));
    }
    pass msaa
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,ExposureGammaPS_MSAA()));
    }
}

technique infra_red
{
	pass main
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_InfraRed()));
	}
	pass msaa
	{
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,PS_InfraRed_MSAA()));
	}
}

technique glow_exposure_gamma
{
    pass main
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,GlowExposureGammaPS()));
    }
    pass msaa
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_5_0);
		SetPixelShader(CompileShader(ps_5_0,GlowExposureGammaPS_MSAA()));
    }
}

// special blend for 3-colour blending!
//TODO: implement different blend for each RT on all platforms.
BlendState CompositeBlend
{
	BlendEnable[0]	=TRUE;
	//BlendEnable[1]	=TRUE;
	SrcBlend		=ONE;
	DestBlend		=SRC1_COLOR;
	SrcBlendAlpha	=ZERO;
	DestBlendAlpha	=ONE;
    BlendOp			=ADD;
	RenderTargetWriteMask[0]=7;
	RenderTargetWriteMask[1]=7;
};

BlendState CubemapCompositeBlend
{
	BlendEnable[0]	=TRUE;
	//BlendEnable[1]	=TRUE;
	SrcBlend		=ONE;
	DestBlend		=SRC1_COLOR;
    BlendOp			=ADD;
	RenderTargetWriteMask[0]=7;
	RenderTargetWriteMask[1]=7;
};

technique blur
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(AlphaBlend, vec4( 0.0, 0.0, 0.0, 0.0 ), 0xFFFFFFFF );
		SetVertexShader(mainvs_5_0);
        SetGeometryShader(NULL);
		SetPixelShader(CompileShader(ps_5_0,PS_Blur()));
    }
}

fxgroup composite_atmospherics
{
	technique main
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth()));
		}
	}
	technique main_with_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_Godrays()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_Godrays()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_Godrays()));
		}
	}
	technique main_with_lightpass
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_Lightpass()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_Lightpass()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_Lightpass()));
		}
	}
	technique main_with_lightpass_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_Lightpass_Godrays()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_Lightpass_Godrays()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_Lightpass_Godrays()));
		}
	}
}

fxgroup composite_atmospherics_near_interp
{
	technique main
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_NearInterp()));
		}
	}
	technique main_with_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_Godrays_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_Godrays_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_Godrays_NearInterp()));
		}
	}
	technique main_with_lightpass
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_Lightpass_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_Lightpass_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_Lightpass_NearInterp()));
		}
	}
	technique main_with_lightpass_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ReverseDepth_Lightpass_Godrays_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_ForwardDepth_Lightpass_Godrays_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_NoDepth_Lightpass_Godrays_NearInterp()));
		}
	}
}

fxgroup composite_atmospherics_msaa
{
	technique main
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth()));
		}
	}
	technique main_with_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_Godrays()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_Godrays()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_Godrays()));
		}
	}
	technique main_with_lightpass
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass()));
		}
	}
	technique main_with_lightpass_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass_Godrays()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass_Godrays()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass_Godrays()));
		}
	}
}

fxgroup composite_atmospherics_msaa_near_interp
{
	technique main
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_NearInterp()));
		}
	}
	technique main_with_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_Godrays_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_Godrays_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_Godrays_NearInterp()));
		}
	}
	technique main_with_lightpass
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass_NearInterp()));
		}
	}
	technique main_with_lightpass_godrays
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ReverseDepth_Lightpass_Godrays_NearInterp()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_ForwardDepth_Lightpass_Godrays_NearInterp()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_MSAA_NoDepth_Lightpass_Godrays_NearInterp()));
		}
	}
}


fxgroup composite_atmospherics_cubemap
{
	technique cubemap
	{
		pass reverse_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CubemapCompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_Cubemap_ReverseDepth()));
		}
		pass forward_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CubemapCompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_Cubemap_ForwardDepth()));
		}
		pass no_depth
		{
			SetRasterizerState( RenderNoCull );
			SetDepthStencilState( DisableDepth, 0 );
			SetBlendState(CubemapCompositeBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
			SetGeometryShader(NULL);
			SetVertexShader(compositevs_5_0);
			SetPixelShader(CompileShader(ps_5_0,PS_CompositeAtmospherics_Cubemap_NoDepth()));
		}
	}
}



technique simul_glow
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4(1.0,1.0,1.0,1.0 ), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(mainvs_4_0);
		SetPixelShader(CompileShader(ps_4_0,GlowPS()));
    }
}

technique show_depth
{
    pass reverse_depth
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,ShowDepthPS_ReverseDepth()));
	}
	pass forward_depth
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(NoBlend, vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0, Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0, ShowDepthPS_ForwardDepth()));
	}
}

technique textured
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend, vec4(0.0,0.0,0.0,0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,TexturedPS()));
    }
}

technique show_scattering_volume
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(NoBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowScatteringVolume()));
    }
}

technique show_volume
{
    pass p0
    {
		SetRasterizerState( RenderNoCull );
		SetDepthStencilState( DisableDepth, 0 );
		SetBlendState(DontBlend,vec4( 0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF );
        SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_4_0,Debug2DVS()));
		SetPixelShader(CompileShader(ps_4_0,PS_ShowVolume()));
    }
}

technique cubemap_to_screenspace
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(DontBlend,vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_5_0,PS_CubemapToScreenspace()));
	}
}

technique cubemap_to_screenspace_visibility
{
	pass p0
	{
		SetRasterizerState(RenderNoCull);
		SetDepthStencilState(DisableDepth, 0);
		SetBlendState(DontBlend,vec4(0.0, 0.0, 0.0, 0.0), 0xFFFFFFFF);
		SetGeometryShader(NULL);
		SetVertexShader(CompileShader(vs_5_0,VS_SimpleFullscreen()));
		SetPixelShader(CompileShader(ps_5_0,PS_CubemapToScreenspaceVisibility()));
	}
}